{$IFDEF METHODS}
function Backtrack: TIntegerArray; overload;
function Echo: TIntegerArray; overload;
function Flip: TRange; overload;
function Flipped: TRange; overload;
function Invert: Boolean; overload;
function Inverted: TRange; overload;
function Retrograde: TIntegerArray; overload;
function Reverse: Boolean; overload;
function Reversed: TRange; overload;
function Reversify: TRange; overload;
function Reversion: TRange; overload;
function Revert: TRange; overload;
function Rewind: TIntegerArray; overload;
function Rotate32: TRange; overload;
function Toggle: TRange; overload;
function Turnaround: TRange; overload;
{$ENDIF}

{$IFDEF IMPLEMENTATION}
{==============================================================================]
  <Backtrack>
  @action: Returns a TIntegerArray containing the range elements in reverse order
           compared to the natural direction of the range, without modifying the TRange itself.
  @note: Uses direct array allocation and a simple loop to fill values in reverse.
         Fully type-safe and works for both ascending and descending ranges.
[==============================================================================}
function TRange.Backtrack: TIntegerArray; overload;
var
  i, l, s, v: Integer;
begin
  l := Self.Size;
  SetLength(Result, l);
  s := IfThen(Self.Ascending, 1, -1);
  v := (Self.start + ((l - 1) * s));
  for i := 0 to (l - 1) do
    Result[i] := v.Decrease(s);
end;

{==============================================================================]
  <Echo>
  @action: Returns an integer array representing the range enumerated in reverse order,
           starting from Stop and progressing opposite to Wind until all elements are produced.
@note:   The resulting array length equals Size. Values are generated by subtracting Wind from the previous element on each iteration.
         The range instance is not modified. This implementation appends dynamically and may incur repeated reallocations.
[==============================================================================}
function TRange.Echo: TIntegerArray; overload;
var
  s, d: Integer;
begin
  Result := [Self.stop];
  s := Self.Size;
  d := Self.Wind;
  while (s.Decrement > 0) do
    Result := (Result + [Result[High(Result)] - d]);
end;

{==============================================================================]
  <Flip>
  @action: Returns a new range with start and stop exchanged, using an XOR-swap
    sequence instead of a temporary variable.
  @note:
    - Functionally equivalent to swapping Self.start and Self.stop.
    - Relies on bitwise XOR; valid only for integral types.
    - Assumes start and stop are distinct storage locations.
    - Offers no semantic advantage over a simple swap and may reduce clarity.
[==============================================================================}
function TRange.Flip: TRange; overload;
begin
  Result.start := (Self.start xor Self.stop);
  Result.stop := (Result.start xor Self.stop);
  Result.start := (Result.start xor Result.stop);
end;

{==============================================================================]
  <Flipped>
  @action: Returns a new range with start and stop values exchanged, using
           sum–difference arithmetic instead of a temporary variable.
  @note:
    - Functionally equivalent to swapping Self.start and Self.stop.
    - Uses addition and subtraction; may overflow for large integral values.
    - Less explicit and less safe than a direct constructor-based swap.
    - No validation is performed (e.g., start <= stop).
[==============================================================================}
function TRange.Flipped: TRange; overload;
begin
  Result.start := (Self.start + Self.stop);
  Result.stop := (Result.start - Self.stop);
  Result.start := (Result.start - Result.stop)
end;

{==============================================================================]
  <Invert>
  @action: Negates both endpoints of the range in place.
  @note: This is a mutating operation. The range is reflected through the
         origin (0), mapping [start, stop] → [-start, -stop].
         The function returns True if the original range was non-zero
         (i.e. either endpoint was non-zero), and False otherwise.
         Direction and magnitude are preserved, but sign is inverted.
[==============================================================================}
function TRange.Invert: Boolean; overload;
begin
  Result := ((Self.start <> 0) or (Self.stop <> 0));
  Self.start := -Self.start;
  Self.stop := -Self.stop;
end;

{==============================================================================]
  <Inverted>
  @action: Returns a copy of the range with both endpoints negated.
  @note: This is a non-mutating operation. The resulting range is the
         reflection of the original through the origin (0), mapping
         [start, stop] → [-start, -stop].
         Direction and magnitude are preserved.
[==============================================================================}
function TRange.Inverted: TRange; overload;
begin
  Result.start := -Self.start;
  Result.stop := -Self.stop;
end;

{==============================================================================]
  <Retrograde>
  @action: Returns the full range of integers in reverse order relative to the
            range direction, producing a TIntegerArray.
  @note: For ascending ranges, this generates numbers from Stop down to Start.
         For descending ranges, this generates numbers from Stop up to Start.
         If the range is singular (Size = 1), the array contains only Self.Start.
         The resulting array length equals Self.Size.
[==============================================================================}
function TRange.Retrograde: TIntegerArray; overload;
var
  i, s: Integer;
begin
  s := Self.Size;
  if (s = 1) then
    Exit([Self.start]);
  SetLength(Result, s);
  case Self.Ascending of
    True:
    for i := 0 to (s - 1) do
      Result[i] := (((Self.start + s) - 1) - i);
    False:
    for i := 0 to (s - 1) do
      Result[i] := (((Self.start - s) + 1) + i);
  end;
end;

{==============================================================================]
  <Reverse>
  @action: Reverses range, returns True if range was reversed.
  @note: None.
[==============================================================================}
function TRange.Reverse: Boolean; overload;
begin
  Result := Self.Plural;
  if Result then
    Swap(Self.start, Self.stop);
end;

{==============================================================================]
  <Reversed>
  @action: Returns reversed range.
  @note: None.
[==============================================================================}
function TRange.Reversed: TRange; overload;
begin
  Result.start := Self.stop;
  Result.stop := Self.start;
end;

{==============================================================================]
  <Reversify>
  @action: Returns a new range whose bounds are reversed (start and stop swapped),
    preserving the same midpoint as the original range.
  @note:
    - Functionally equivalent to exchanging Self.start and Self.stop.
    - Assumes that start and stop are symmetric endpoints of the range.
    - No validation is performed (e.g., start <= stop).
    - Uses Int64 arithmetic; extreme values may overflow when summed.
[==============================================================================}
function TRange.Reversify: TRange; overload;
var
  s: Int64;
begin
  s := (Self.start + Self.stop);
  Result.start := (s - Self.start);
  Result.stop := (s - Self.stop);
end;

{==============================================================================]
  <Reversion>
  @action: Returns a new TRange object representing the **reverse of the current range**.
           The new range starts at the original Stop and ends at the original Start,
           preserving the step direction.
  @note: For ascending ranges, the returned range counts down from Stop to Start.
         For descending ranges, the returned range counts up from Stop to Start.
         The size of the range remains the same as the original.
[==============================================================================}
function TRange.Reversion: TRange; overload;
begin
  Result := Range((Self.start + ((Self.Size - 1) * IfThen(Self.Ascending, 1, -1))), Self.start);
end;

{==============================================================================]
  <Revert>
  @action: Returns a new TRange object representing the **reversed range**,
           calculated from the original Start and Size. The new range starts
           at the original Stop and ends at the original Start, preserving
           the original step direction.
  @note: This differs from Reversion in that it explicitly computes the
         Start and Stop values using the Size and Ascending flag, rather
         than using the Range helper. For ascending ranges, the returned
         range counts down; for descending ranges, it counts up.
[==============================================================================}
function TRange.Revert: TRange; overload;
var
  s: Integer;
  a: Boolean;
begin
  s := (Self.Size - 1);
  a := Self.Ascending;
  Result.start := (Self.start + (s * IfThen(a, 1, -1)));
  Result.stop := IfThen(a, (Result.start - s), (Result.start + s));
end;

{==============================================================================]
  <Rewind>
  @action: Returns a TIntegerArray containing all values of the range
           in **reverse order** relative to the range direction.
  @note:
    - Works for ascending or descending ranges.
    - If the range is singular (Size = 1), the array contains only Self.Start.
    - The array length equals Self.Size.
[==============================================================================}
function TRange.Rewind: TIntegerArray; overload;
var
  i, s: Integer;
begin
  s := Self.Size;
  if (s = 1) then
    Exit([Self.start]);
  SetLength(Result, s);
  for i := 0 to (s - 1) do
    if Self.Ascending then
      Result[i] := (Self.stop - i)
    else
      Result[i] := (Self.stop + i);
end;

{==============================================================================]
  <Rotate32>
  @action: Rotates the 64-bit value left by 32 bits.
  @note: Equivalent to swapping the high and low 32-bit words.
[==============================================================================}
function TRange.Rotate32: TRange; overload;
var
  c: Int64;
begin
  c := Int64(Self);
  Int64(Result) := ((c shl 32) or (c shr 32));
end;

{==============================================================================]
  <Toggle>
  @action: Returns a new range with its start and stop values exchanged.
  @note:
    - Purely swaps the range bounds.
    - No arithmetic or bitwise operations involved.
    - Clearer and safer than XOR- or sum-based swap implementations.
    - No validation is performed (e.g., start <= stop).
[==============================================================================}
function TRange.Toggle: TRange; overload;
begin
  Result := TRange.Construct(Self.stop, Self.start);
end;

{==============================================================================]
  <Turnaround>
  @action: Returns a new TRange representing the same interval
           with its direction reversed.
  @note: - The new Start becomes the original terminal value
           (computed via Span).
         - The new Stop becomes the original Start.
         - Assumes unit step (±1).
         - Works correctly for negative Start values.
[==============================================================================}
function TRange.Turnaround: TRange; overload;
begin
  if Self.Ascending then
    Result.start := (Self.start + Self.Span)
  else
    Result.start := (Self.start - Self.Span);
  Result.stop := Self.start;
end;
{$ENDIF}